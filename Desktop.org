#+TITLE: Desktop Environment
#+AUTHOR: Demis Balbach
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args :tangle-mode (identity #o444)

This file contains the configuration for my desktop system. This includes my configuration- or dotfiles. Please note however, that it does not include my emacs configuration. It is separated into its own ORG file.
This file will tangle various files. One of which is =desktop.scm=, which is used to install the desktop profile in Guix. It's path is =~/.config/guix/manifests/desktop.scm=.
#+begin_src scheme :tangle ~/.config/guix/manifests/desktop.scm :noweb yes :mkdirp yes
;; This file is auto-generated. Do not make changes manually.
;; Exported from Desktop.org

(specifications->manifest
 '(
   <<packages>>
   ))
#+end_src

* Table Of Contents :TOC:
- [[#environment][Environment]]
  - [[#exports][Exports]]
  - [[#scripts][Scripts]]
  - [[#fonts][Fonts]]
- [[#applications][Applications]]
  - [[#git][Git]]
  - [[#browsers][Browsers]]
  - [[#gnupg][GnuPG]]
  - [[#openssh][OpenSSH]]
  - [[#zshell][ZShell]]
- [[#local-variables][Local Variables]]

* Environment
:PROPERTIES:
:header-args:sh: :tangle ~/.config/profile
:header-args:sh: :mkdirp yes
:END:

There are many ways to configure the user environment. This is Linux after all. I decided to have my system source one file inside my user directory, which will then set up the environment to my liking. The file to be source is located in =$HOME/.config/profile=. It is suppose to be what is usually referred to as =~/.profile=. However, because I like to keep my home folder as clean as possible I moved it to =~/.config=. But how does it get sourced? Please take a look at my system level =zsh= setup at [[System.org][System.org]]. It's explained there. The purpose of this file is to setup my user environment, not my shell (Prompt, aliases, ...). Everything that goes in here should be available ASAP.

Let's create the file.

#+begin_src sh :tangle-mode (identity #o755)
## This file is auto-generated. Do not make changes manually.
## Exported from Desktop.org
#+end_src

** Exports
This section covers all the global variables I define in my =profile=. This includes all =export= statements.
  
*** Guix profile
I use GNU/Guix as my operating system of choice (it's great, you should too!). The very first thing I need to do is to export =$GUIX_PROFILE= so Guix knows where to find my profile. 
#+begin_src sh
export GUIX_PROFILE="${HOME}"/.guix-profile
. "/etc/profile"
#+end_src

Apart from the default profile, Guix allows me to add custom profile which group certain packages into separate files. This code block activates all available profiles. That means, after you installed them, their packages get usable.
#+begin_src sh
export GUIX_EXTRA_PROFILES="${HOME}"/.guix-extra-profiles
for i in ${GUIX_EXTRA_PROFILES}/*; do
    profile=$i/$(basename "$i")
    if [ -f "${profile}"/etc/profile ]; then
	    GUIX_PROFILE="${profile}"
	    . "${GUIX_PROFILE}"/etc/profile
    fi
    unset profile
done
#+end_src

You can install (or update) a profile like so
#+begin_src sh :tangle no
guix package --manifest=/path/to/guix-my-project-manifest.scm --profile="$GUIX_EXTRA_PROFILES"/my-project/my-project
#+end_src
    
*** XDG base directories
After setting =$GUIX_PROFILE=, the most important thing for me is to properly set my base directories following the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html#variables][XDG specification]]. With Guix, I do not need to set =$XDG_DATA_DIRS= and =$XDG_CONFIG_DIRS= (you could of course add to them with =export XDG_CONFIG_DIRS=<your path>:$XDG_CONFIG_DIRS=) because it is already set by default. I'm fine with the default so I commented the section out.
#+begin_src sh
export XDG_CONFIG_HOME="${HOME}"/.config
export XDG_CACHE_HOME="${HOME}"/.cache
export XDG_DATA_HOME="${HOME}"/.local/share
# export XDG_DATA_DIRS="/usr/local/share:/usr/share"
# export XDG_CONFIG_DIRS="/etc/xdg"

# Setting $XDG_RUNTIME_DIR
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/tmp/${UID}-runtime-dir
    if ! test -d "${XDG_RUNTIME_DIR}"; then
	    mkdir "${XDG_RUNTIME_DIR}"
	    chmod 0700 "${XDG_RUNTIME_DIR}"
    fi
fi
#+end_src

*** Custom directories
I need a couple of custom directories. For now, =$GITDIR= is where I store all my cloned git repositories, this includes projects I'm working on. I should probably derive a =$WORKDIR= variable from it to house my work related projects, but for now this is good. =$BINDIR= is the path to my local binaries, this would include shell scripts I need system wide access to. Hence why I add it to the =$PATH=.

#+begin_src sh
export GITDIR="${XDG_DATA_HOME}"/git
export BINDIR="${XDG_DATA_HOME}"/bin
export PATH="${BINDIR}:$PATH"
#+end_src

I used to use =doom-emacs= (and maybe I will again). It places its CLI binary into a =bin= folder inside your emacs configuration. It's probably useful to add this to the path as well.
#+begin_src sh
export PATH="${XDG_CONFIG_HOME}/emacs/bin:${PATH}"
#+end_src

*** Default applications
Next are variables to declare default applications. Stuff like =$BROWSER= and =$EDITOR= goes in here. Again, there is no need to set =$SHELL= manually. Guix sets it by default.

#+begin_src sh
export VISUAL="emacsclient"
export EDITOR="${VISUAL}"
export BROWSER="next"
#+end_src

*** Application specific variables
This section covers application-specific exports. This, for the most part, is an effort in keeping my home directory clean. I set my =$XDG_CONFIG_HOME= to =$HOME/.config=, and many applications respect that, which is great. However, there still is a plethora of applications that are not aware of it and have default config file paths in =$HOME=.
However, many, but not all (looking at you, [[https://bugzilla.mindrot.org/show_bug.cgi?id=2050][ssh]]) of them can be configured to be aware of where I want them to put their config files.
The Arch-Wiki offers a good [[https://wiki.archlinux.org/title/XDG_Base_Directory][list]] of applications that can be configured that way.

This is a list containing generic exports I need. However, each application may export its own environment variables using the =env-exports= reference.

#+begin_src sh :noweb yes
export CC="gcc"
export CUDA_CACHE_PATH="${XDG_CACHE_HOME}"/nv
export DOCKER_CONFIG="${XDG_CONFIG_HOME}"/docker
export EMACS_USER_DIRECTORY="${XDG_CONFIG_HOME}"/emacs
export LC_COLLATE="C"
export NPM_CONFIG_USERCONFIG="${XDG_CONFIG_HOME}"/npm/npmrc
export PASSWORD_STORE_DIR="${XDG_DATA_HOME}"/pass
<<env-exports>>
#+end_src
    
** Scripts
This section houses all my shell scripts. They will all be tangled to =$BINDIR=. That way, I have access to them when I need to.

*** Install/Update manifests
This scripts installs or updates a given manifest. It's [[https://en.wikipedia.org/wiki/KISS_principle][KISS]]. If I need to extend it, I will. Same goes for everything I do.

#+begin_src sh :tangle ~/.local/share/bin/update-manifest :tangle-mode (identity #o755) :shebang "#!/bin/sh"
if [ -n "$1" ]; then
    DEST="${GUIX_EXTRA_PROFILES}"/"$1"/"$1"
    if [ ! -d "${DEST}" ]; then
	    mkdir -p "${DEST}"
    fi
    guix package \
	    -m "${XDG_CONFIG_HOME}"/guix/manifests/"$1".scm \
	    -p "${DEST}"
else
    echo "Manifest name missing."
fi
#+end_src

** Fonts
In terms of configuration, I don't pack all the fonts I install together. I rather install and describe them in the context where they are needed. However, for fonts to work in general, I need to add the proper path to =fontconfig=. This needs to be done for every profile that installs fonts. Fortunately, =fontconfig= supports the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html#variables][XDG directory specification]]. This means I can use =${XDG_CONFIG_HOME}/fontconfig= to configure it.

#+begin_src xml :tangle ~/.config/fontconfig/fonts.conf
<?xml version="1.0"?>
<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
  <dir>~/.guix-extra-profiles/desktop/desktop/share/fonts</dir>
  <dir>~/.guix-extra-profiles/emacs/emacs/share/fonts</dir>
</fontconfig>
#+end_src

* Applications

** Git
This is how I globally configure git. At this point, this is just a basic configuration that sets my user as well as my signing key. *Note*: I set my editor to emacs. That way, If I ever wanted to commit something from the terminal, emacs opens in a new frame.

#+begin_src conf :tangle ~/.config/git/config :mkdirp yes
[user]
name = Demis Balbach
email = db@minikn.xyz
signingKey = F17DDB98CC3C405C
[core]
editor = emacsclient -c
[commit]
gpgSign = true
[gpg]
program = gpg
#+end_src

** Browsers

*** Chromium

GNU/Guix offers an [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/chromium.scm#n476][ungoogled]] version of the chromium browser which I like to use. However, because I use wayland, I have to explicitly instruct chromium to use it.

#+begin_src scheme :noweb-ref packages
"ungoogled-chromium-wayland"
#+end_src

** GnuPG
I use [[https://gnupg.org/][GnuPG]] to manage my key chain. I also configure it to work well with Emacs. Because I work from within Emacs most of the time I use =pinentry-emacs= to control passphrase prompts. Take a look at [[Emacs.org][Emacs.org]] for details.
In my ZShell config, I set =$GNUPGHOME= to =$XDG_DATA_HOME/gnupg= which defaults to =$HOME/.local/share/gnupg= in my case. Now I need to set up the GPG agent to work with my setup. Unfortunately, its configuration only accepts hardcoded paths.

#+begin_src sh :noweb-ref env-exports
export GNUPGHOME="${XDG_DATA_HOME}"/gnupg
#+end_src

In order to default to the new =$GNUPGHOME=, we have to define an alias to use.

#+begin_src sh :noweb-ref env-aliases
alias gpg="gpg --homedir ${GNUPGHOME}"
#+end_src

#+begin_src conf :tangle ~/.local/share/gnupg/gpg-agent.conf :mkdirp yes
pinentry-program /home/db/.guix-extra-profiles/desktop/desktop/bin/pinentry-emacs
enable-ssh-support
allow-emacs-pinentry
allow-loopback-pinentry
#+end_src

The GPG agent can also take care of authentication through =ssh=. We just need a =sshcontrol= file in the same place with our authentication keygrip.

#+begin_src conf :tangle ~/.local/share/gnupg/sshcontrol :mkdirp yes
E3FFA5A1B444A4F099E594758008C1D8845EC7C0
#+end_src

In order for this to work, we need a GPG keychain (obviously). I have my keychain saved on a USB drive. Together with the management of my password store, this is the only thing about my setup I do not try to automate. So what I would do at this point is copy my keychain from the USB drive to =$GNUPGHOME=.

#+begin_src scheme :noweb-ref packages
"pinentry-emacs"
"gnupg"
#+end_src

** OpenSSH
Tell SSH to use the gpg-agent for authentication

#+begin_src sh :noweb-ref env-exports
export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
#+end_src

#+begin_src scheme :noweb-ref packages
"openssh"
#+end_src

** ZShell
:PROPERTIES:
:header-args:sh: :tangle ~/.config/zsh/.zshrc
:header-args:sh: :mkdirp yes
:END:
I use =zsh= as my main shell. I have configured my [[System.org][system]] in a way so that =$ZDOTDIR= is automatically set to =$HOME/.config/zsh=. This is the entry for my shell  configuration.
By default, =zsh= will look for a =.zshrc= inside =$ZDOTDIR=. Let's do it.

#+begin_src sh
## This file is auto-generated. Do not make changes manually.
## Exported from Desktop.org
#+end_src

#+begin_src scheme :noweb-ref packages
"zsh"
#+end_src

*** Basic settings
This covers the basic settings, like =HISTSIZE=, I configured my =zsh= with. Plugins, like syntax-highlighting have add to the file's tail. They therefore appear last in this chapter.

#+begin_src sh
HISTFILE="${XDG_DATA_HOME}"/zsh/history
HISTSIZE=1000
SAVEHIST=1000
setopt nomatch
unsetopt beep
bindkey -e

# Add to $fpath so that we can install plugins
FPATH_FUNCTION_DIR="${ZDOTDIR}"/functions
if [ ! -d ${FPATH_FUNCTION_DIR} ]; then
    mkdir -p ${FPATH_FUNCTION_DIR}
fi
fpath=( ${FPATH_FUNCTION_DIR} $fpath )
#+end_src
*** Aliases
This section covers all of my aliases. To some extend, this also includes aliases to applications which offer a =--config= (or similar) parameter for its config directory. There is an argument to be made whether one should rather keep this somewhere else (maybe a section of each application with =export=\s and =alias=\es bundled together). However, I decided to split it like this.

**** Navigation helpers
First some handy aliases to navigate the shell.

#+begin_src sh
alias lss="ls --group-directories-first --color=always -laAh"
alias ..="cd .."
alias ...="cd ../../"
alias ....="cd ../../../"
#+end_src

**** Application specific aliases

This is a list containing generic aliases I need. However, each application may define its own aliases using the =env-aliases= reference.

#+begin_src sh :noweb yes
alias dall="d-stp; d-rmc; d-rmv; d-rmi"
alias drmc="docker rm $(docker ps -aq)"
alias drmi="docker rmi $(docker images -q)"
alias drmv="docker volume rm $(docker volume ls -q)"
alias dstp="docker stop $(docker ps -aq)"
alias mbsync="mbsync -c ${XDG_CONFIG_HOME}/isync/mbsyncrc"
alias next="next --session nil"
alias qutebrowser="qutebrowser -R"
<<env-aliases>>
#+end_src
*** Plugins
ZShell has the ability to install plugins quite easily. This section covers all the various plugins I use for my setup.

**** Basic plugins
Some basic plugins like =colors= and =compinit=
#+begin_src sh
zstyle :compinstall filename '${ZDOTDIR}/.zshrc'
autoload -Uz compinit && compinit
autoload -U colors && colors
#+end_src

**** TODO Prompt
This covers my prompt. I recently switched to [[https://github.com/spaceship-prompt/spaceship-prompt][starship]]. However, in order for it to work properly, I need to symlink the installed packaged to =$FPATH_FUNCTION_DIR=.

*Note*: This will not work if the profile =starship-prompt= has been installed with is not called =desktop=. This needs some further tweaking.
#+begin_src sh
if [ ! -d "${FPATH_FUNCTION_DIR}"/prompt_spaceship_setup ]; then
    ln -sf "${GUIX_EXTRA_PROFILES}"/desktop/desktop/lib/spaceship-prompt/spaceship.zsh "${FPATH_FUNCTION_DIR}"/prompt_spaceship_setup
fi
autoload -U promptinit && promptinit
prompt spaceship
#+end_src

#+begin_src scheme :noweb-ref packages
"spaceship-prompt"
"font-tamzen"
#+end_src

**** TODO Syntax highlighting
The plugin for syntax highlighting must be sourced at the end of the tangled =.zshrc=. Therefore nothing should follow this plugin. More information can be found [[https://github.com/zsh-users/zsh-syntax-highlighting#why-must-zsh-syntax-highlightingzsh-be-sourced-at-the-end-of-the-zshrc-file][here]].

*Note*: This will not work if the profile =zsh-syntax-highlighting= has been installed with is not called =desktop=. This needs some further tweaking.
#+begin_src sh
if [ -d "${GUIX_EXTRA_PROFILES}"/desktop/desktop/share/zsh-syntax-highlighting ]; then
    . "${GUIX_EXTRA_PROFILES}"/desktop/desktop/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi
#+end_src

#+begin_src scheme :noweb-ref packages
"zsh-syntax-highlighting"
#+end_src

* Local Variables
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (if (y-or-n-p "Reload Desktop profile?") (message (shell-command-to-string "update-manifest desktop")))) nil t)
# eval: (add-hook 'after-save-hook (lambda () (if (y-or-n-p "Tangle the file?") (org-babel-tangle))) nil t)
# End:
